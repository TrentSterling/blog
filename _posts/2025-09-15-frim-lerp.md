---
title: "Stop Doing lerp(a, b, dt * speed)"
date: 2025-09-15
categories: [devblog]
tags: [unity, csharp, gamedev, tutorial, math, optimization]
description: "Your lerp is framerate-dependent. Here's how to fix it with FRIM lerp."
image: "/assets/img/blog/frim-lerp.png"
---

![FRIM Lerp Demo](/assets/img/blog/frim-lerp.png){: .align-center }

i see this all the time in Unity projects:

```csharp
transform.position = Vector3.Lerp(transform.position, target, Time.deltaTime * 5f);
```

it looks smooth on your machine, and then someone with a 144hz monitor or a potato laptop gets a completely different feel. because it's **framerate-dependent**.

[Interactive Demo](https://tront.xyz/lerp/) - watch the 10/30/60 FPS canvases side by side. the broken version moves at different speeds. the fixed version is perfectly synced.

## why it breaks

there are two common mistakes:

**mistake 1:** using a constant `t` value like `lerp(a, b, 0.05)`. this gets applied every frame, so higher framerates apply it more often and move faster.

**mistake 2:** multiplying by `deltaTime` like `lerp(a, b, dt * 5)`. this seems right but it's not mathematically sound. worse; if `dt * 5` ever exceeds 1.0 during a lag spike, you overshoot the target and get jitter.

the fix is **exponential decay**. instead of a linear approximation, you calculate the lerp factor so that the same fraction of distance is covered over the same real-world time, regardless of framerate. this is called **FRIM lerp** (Framerate-Independent Motion).

## the three solutions

here are three equivalent ways to do it, each parameterized differently. pick whichever makes the most sense for your use case.

### half-life (Freya Holmer's approach)

the most intuitive version. you specify "how many seconds to get halfway to the target." smaller = faster.

```csharp
public static float LerpFrimHalfLife(this float source, float target, float halfLife, float deltaTime)
{
    return Mathf.Lerp(source, target, 1f - Mathf.Pow(2f, -deltaTime / halfLife));
}

// usage:
currentValue = currentValue.LerpFrimHalfLife(targetValue, 0.2f, Time.deltaTime);
```

### smoothing factor (Ashley / Construct)

a value from 0-1 representing how much distance remains after one second. `0.1` means 10% remains (90% covered) after one second.

```csharp
public static float LerpFrim(this float source, float target, float smoothing, float deltaTime)
{
    return Mathf.Lerp(source, target, 1f - Mathf.Pow(smoothing, deltaTime));
}

// usage:
currentValue = currentValue.LerpFrim(targetValue, 0.1f, Time.deltaTime);
```

### decay constant (Rory Driscoll)

uses a lambda value; higher = faster. common in physics/engineering contexts.

```csharp
public static float LerpFrimLambda(this float source, float target, float lambda, float deltaTime)
{
    return Mathf.Lerp(source, target, 1f - Mathf.Exp(-lambda * deltaTime));
}

// usage:
currentValue = currentValue.LerpFrimLambda(targetValue, 5f, Time.deltaTime);
```

## which one to use

**half-life** is my recommendation for most gamedev use cases. "get halfway there in 0.2 seconds" is easy to reason about and easy for designers to tune. the smoothing factor and lambda versions are mathematically equivalent; just parameterized differently.

all three work on `Vector3` too; the [SmoothingExtensions.cs](https://tront.xyz/lerp/SmoothingExtensions.cs) file on the demo page has both `float` and `Vector3` versions ready to drop in.

## credits

this page pulls together work from three people who've explained this really well:

- [Rory Driscoll](https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/) - the exponential decay breakdown
- [Ashley (Construct)](https://www.construct.net/en/blogs/ashleys-blog-2/using-lerp-delta-time-924) - mathematical proof of why approximations fail
- [Freya Holmer](https://mastodon.social/@acegikmo/111928099302633045) - the half-life parameterization

> hope you dont do `lerp(a,b,dt*5);` !!!
